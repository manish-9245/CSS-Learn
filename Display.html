import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import sqlite3

# Generate realistic time series data with non-negative values
np.random.seed(0)
num_rows = 1000
start_date = datetime(2023, 1, 1)
end_date = start_date + timedelta(hours=num_rows - 1)
timestamps = pd.date_range(start_date, end_date, freq='H')
num_fields = 10
data = pd.DataFrame(np.abs(np.random.randn(num_rows, num_fields)),
                    index=timestamps,
                    columns=["CPU Usage (%)", "Memory Usage (%)",
                             "Network Throughput (Mbps)",
                             "Disk Latency (ms)", "Request Latency (ms)",
                             "Error Rate (%)", "Server Load (%)",
                             "Response Time (ms)", "Availability (%)",
                             "CPU Temperature (°C)"])

# Create an in-memory SQLite database
conn = sqlite3.connect(":memory:")
data.to_sql("data", conn)

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = pd.read_sql_query(query, conn)
        query_result["timestamp"] = pd.to_datetime(query_result["timestamp"])
        query_result.set_index("timestamp", inplace=True)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i + 1}:** `{query_list[i]}`")
        st.dataframe(result, height=200, width=800)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]

    # Select x-axis field (timestamp)
    x_axis_field = "timestamp"

    # Select y-axis fields
    available_fields = [field for field in selected_result.columns if field != x_axis_field]
    selected_fields = st.multiselect("Select y-axis fields:", available_fields, default=available_fields)

    if selected_fields:
        chart_data = selected_result[selected_fields]
        st.line_chart(chart_data, use_container_width=True)










import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import sqlite3

# Generate realistic time series data with non-negative values
np.random.seed(0)
num_rows = 1000
start_date = datetime(2023, 1, 1)
end_date = start_date + timedelta(hours=num_rows-1)
timestamps = pd.date_range(start_date, end_date, freq='H')
num_fields = 10
data = pd.DataFrame(np.abs(np.random.randn(num_rows, num_fields)),
                    index=timestamps,
                    columns=["CPU Usage (%)", "Memory Usage (%)",
                             "Network Throughput (Mbps)",
                             "Disk Latency (ms)", "Request Latency (ms)",
                             "Error Rate (%)", "Server Load (%)",
                             "Response Time (ms)", "Availability (%)",
                             "CPU Temperature (°C)"])

# Create an in-memory SQLite database
conn = sqlite3.connect(":memory:")
data.to_sql("data", conn)

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = pd.read_sql_query(query, conn)
        query_result["Timestamp"] = pd.to_datetime(query_result["Timestamp"])
        query_result.set_index("Timestamp", inplace=True)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i+1}:** `{query_list[i]}`")
        st.dataframe(result, height=200, width=800)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]

    # Select x-axis field (Timestamp)
    x_axis_field = "Timestamp"

    # Select y-axis fields
    available_fields = [field for field in selected_result.columns if field != x_axis_field]
    selected_fields = st.multiselect("Select y-axis fields:", available_fields, default=available_fields)

    if selected_fields:
        chart_data = selected_result[selected_fields]
        st.line_chart(chart_data, use_container_width=True)










import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import sqlite3

# Generate realistic time series data with non-negative values
np.random.seed(0)
num_rows = 1000
start_date = datetime(2023, 1, 1)
end_date = start_date + timedelta(days=num_rows-1)
timestamps = pd.date_range(start_date, end_date, freq='H')
num_fields = 10
data = pd.DataFrame(np.abs(np.random.randn(num_rows, num_fields)),
                    index=timestamps,
                    columns=["CPU Usage (%)", "Memory Usage (%)",
                             "Network Throughput (Mbps)",
                             "Disk Latency (ms)", "Request Latency (ms)",
                             "Error Rate (%)", "Server Load (%)",
                             "Response Time (ms)", "Availability (%)",
                             "CPU Temperature (°C)"])

# Create an in-memory SQLite database
conn = sqlite3.connect(":memory:")
data.to_sql("data", conn)

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = pd.read_sql_query(query, conn)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i+1}:** `{query_list[i]}`")
        st.dataframe(result, height=200, width=800)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]

    # Select x-axis field (Timestamp)
    x_axis_field = "Timestamp"

    # Select y-axis fields
    available_fields = [field for field in selected_result.columns if field != x_axis_field]
    selected_fields = st.multiselect("Select y-axis fields:", available_fields, default=available_fields)

    if selected_fields:
        chart_data = selected_result[selected_fields + [x_axis_field]]
        chart_data = chart_data.set_index(x_axis_field)
        st.line_chart(chart_data, use_container_width=True)










import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
import sqlite3

# Generate random data
np.random.seed(0)
dates = pd.date_range(datetime(2023, 1, 1), periods=100)
data = pd.DataFrame(np.random.randn(100, 10), index=dates, columns=["CPU Usage (%)", "Memory Usage (%)",
                                                                    "Network Throughput (Mbps)",
                                                                    "Disk Latency (ms)", "Request Latency (ms)",
                                                                    "Error Rate (%)", "Server Load (%)",
                                                                    "Response Time (ms)", "Availability (%)",
                                                                    "CPU Temperature (°C)"])
data.index.name = "Timestamp"  # Labeling the date time column as "Timestamp"

# Create an in-memory SQLite database
conn = sqlite3.connect(":memory:")
data.to_sql("data", conn)

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = pd.read_sql_query(query, conn)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i+1}:** `{query_list[i]}`")
        st.dataframe(result, height=200, width=800)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]
    x_axis_field = st.selectbox("Select x-axis field:", ["Timestamp"] + selected_result.columns.tolist())
    y_axis_field = st.selectbox("Select y-axis field:", selected_result.columns.tolist())

    if x_axis_field == "Timestamp":
        x = selected_result.index
    else:
        x = selected_result[x_axis_field]

    y = selected_result[y_axis_field]

    chart_data = pd.DataFrame({x_axis_field: x, y_axis_field: y})
    st.line_chart(chart_data)










import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
import sqlite3

# Generate random data
np.random.seed(0)
dates = pd.date_range(datetime(2023, 1, 1), periods=100)
data = pd.DataFrame(np.random.randn(100, 10), index=dates, columns=["CPU Usage (%)", "Memory Usage (%)",
                                                                    "Network Throughput (Mbps)",
                                                                    "Disk Latency (ms)", "Request Latency (ms)",
                                                                    "Error Rate (%)", "Server Load (%)",
                                                                    "Response Time (ms)", "Availability (%)",
                                                                    "CPU Temperature (°C)"])
data.index.name = "Timestamp"  # Labeling the date time column as "Timestamp"

# Create an in-memory SQLite database
conn = sqlite3.connect(":memory:")
data.to_sql("data", conn)

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = pd.read_sql_query(query, conn)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i+1}:** `{query_list[i]}`")
        st.dataframe(result, height=200, width=800, scrollable=True)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]
    x_axis_field = st.selectbox("Select x-axis field:", ["Timestamp"] + selected_result.columns.tolist())
    y_axis_field = st.selectbox("Select y-axis field:", selected_result.columns.tolist())

    if x_axis_field == "Timestamp":
        x = selected_result["Timestamp"]
    else:
        x = selected_result[x_axis_field]

    y = selected_result[y_axis_field]

    chart_data = pd.DataFrame({x_axis_field: x, y_axis_field: y})
    st.line_chart(chart_data)





import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
import sqlite3

# Generate random data
np.random.seed(0)
dates = pd.date_range(datetime(2023, 1, 1), periods=100)
data = pd.DataFrame(np.random.randn(100, 10), index=dates, columns=["CPU Usage (%)", "Memory Usage (%)",
                                                                    "Network Throughput (Mbps)",
                                                                    "Disk Latency (ms)", "Request Latency (ms)",
                                                                    "Error Rate (%)", "Server Load (%)",
                                                                    "Response Time (ms)", "Availability (%)",
                                                                    "CPU Temperature (°C)"])
data.index.name = "Timestamp"  # Labeling the date time column as "Timestamp"

# Create an in-memory SQLite database
conn = sqlite3.connect(":memory:")
data.to_sql("data", conn)

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = pd.read_sql_query(query, conn)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i+1}:** `{query_list[i]}`")
        st.dataframe(result)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]
    x_axis_field = st.selectbox("Select x-axis field:", ["Timestamp"] + selected_result.columns.tolist())
    y_axis_field = st.selectbox("Select y-axis field:", selected_result.columns.tolist())

    if x_axis_field == "Timestamp":
        x = selected_result["Timestamp"]
    else:
        x = selected_result[x_axis_field]

    y = selected_result[y_axis_field]

    st.line_chart(data=pd.DataFrame({x_axis_field: x, y_axis_field: y}))










import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
from pandasql import sqldf

# Generate random data
np.random.seed(0)
dates = pd.date_range(datetime(2023, 1, 1), periods=100)
data = pd.DataFrame(np.random.randn(100, 10), index=dates, columns=["CPU Usage (%)", "Memory Usage (%)",
                                                                    "Network Throughput (Mbps)",
                                                                    "Disk Latency (ms)", "Request Latency (ms)",
                                                                    "Error Rate (%)", "Server Load (%)",
                                                                    "Response Time (ms)", "Availability (%)",
                                                                    "CPU Temperature (°C)"])
data.index.name = "Timestamp"  # Labeling the date time column as "Timestamp"

# Register data as a table
pysqldf = lambda q: sqldf(q, globals())

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = pysqldf(query)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i+1}:** `{query_list[i]}`")
        st.dataframe(result)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]
    x_axis_field = st.selectbox("Select x-axis field:", ["Timestamp"] + selected_result.columns.tolist())
    y_axis_field = st.selectbox("Select y-axis field:", selected_result.columns.tolist())

    if x_axis_field == "Timestamp":
        x = selected_result.index
    else:
        x = selected_result[x_axis_field]

    y = selected_result[y_axis_field]

    st.line_chart(data=pd.DataFrame({x_axis_field: x, y_axis_field: y}))






import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
from pandasql import sqldf

# Generate random data
np.random.seed(0)
dates = pd.date_range(datetime(2023, 1, 1), periods=100)
data = pd.DataFrame(np.random.randn(100, 10), index=dates, columns=["CPU Usage (%)", "Memory Usage (%)",
                                                                    "Network Throughput (Mbps)",
                                                                    "Disk Latency (ms)", "Request Latency (ms)",
                                                                    "Error Rate (%)", "Server Load (%)",
                                                                    "Response Time (ms)", "Availability (%)",
                                                                    "CPU Temperature (°C)"])
data.index.name = "Timestamp"  # Labeling the date time column as "Timestamp"

# Register data as a table
sqldf = lambda q: pd.DataFrame(sqldf(q, globals()))

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = sqldf(query)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i+1}:** `{query_list[i]}`")
        st.dataframe(result)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]
    x_axis_field = st.selectbox("Select x-axis field:", ["Timestamp"] + selected_result.columns.tolist())
    y_axis_field = st.selectbox("Select y-axis field:", selected_result.columns.tolist())

    if x_axis_field == "Timestamp":
        x = selected_result.index
    else:
        x = selected_result[x_axis_field]

    y = selected_result[y_axis_field]

    st.line_chart(data=pd.DataFrame({x_axis_field: x, y_axis_field: y}))







import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
from pandasql import sqldf

# Generate random data
np.random.seed(0)
dates = pd.date_range(datetime(2023, 1, 1), periods=100)
data = pd.DataFrame(np.random.randn(100, 10), index=dates, columns=["CPU Usage (%)", "Memory Usage (%)",
                                                                    "Network Throughput (Mbps)",
                                                                    "Disk Latency (ms)", "Request Latency (ms)",
                                                                    "Error Rate (%)", "Server Load (%)",
                                                                    "Response Time (ms)", "Availability (%)",
                                                                    "CPU Temperature (°C)"])
data.index.name = "Timestamp"  # Labeling the date time column as "Timestamp"

# Helper function to execute SQL queries
def run_query(query):
    pysqldf = sqldf(globals())
    result = pysqldf.execute(query)
    return result

# Register data as a table
globals()["data"] = data

# Display initial DataFrame
st.write("Initial Data")
st.dataframe(data)

# Query execution and visualization
query_list = []
query_results = []

# Query input box
query = st.text_area("Enter SQL query:")
if st.button("Run Query"):
    try:
        query_result = run_query(query)
        query_results.append(query_result)
        query_list.append(query)
        st.success("Query executed successfully!")
    except Exception as e:
        st.error(f"Error: {str(e)}")

# Display query results
if len(query_results) > 0:
    st.write("Query Results")
    for i, result in enumerate(query_results):
        st.write(f"**Query {i+1}:** `{query_list[i]}`")
        st.dataframe(result)

# Visualization
if len(query_results) > 0:
    st.write("Visualizations")
    selected_query = st.selectbox("Select query:", query_list)
    selected_result = query_results[query_list.index(selected_query)]
    x_axis_field = st.selectbox("Select x-axis field:", ["Timestamp"] + selected_result.columns.tolist())
    y_axis_field = st.selectbox("Select y-axis field:", selected_result.columns.tolist())

    if x_axis_field == "Timestamp":
        x = selected_result.index
    else:
        x = selected_result[x_axis_field]

    y = selected_result[y_axis_field]

    st.line_chart(data=pd.DataFrame({x_axis_field: x, y_axis_field: y}))



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Display</title>
    <style>
        .bluebox{
            background-color:#0674E7;
            color: white;
            width: auto;
            height:50px;
           /* visibility:hidden;*/
           /* display:none;*/

        }
        .yellowbox{
            background-color: #f7f707;
            height:100px;

        }
        .greenbox{
            height:75px;
            background-color: rgb(25, 240, 79);
        }
        .great{
            background-color: rgb(220, 255, 239);
            color: black;
            display:block;
        }
    </style>
</head>
<body>
    <div>
        <p class="bluebox">Facebook is <span class="great">great</span></p>
        <p class="yellowbox">Apple</p>
        <p class="greenbox">Microsoft</p>
    </div>
</body>
</html>